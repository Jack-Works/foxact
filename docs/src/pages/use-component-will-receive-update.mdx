---
title: useComponentWillReceiveUpdate
---

# useComponentWillReceiveUpdate

import ExportMetaInfo from '../components/export-meta-info';

<ExportMetaInfo />

Reset part of states when props changed.

## Usage

```js
import { useComponentWillReceiveUpdate } from 'foxact/use-abortable-effect';

function Component(props) {
  const [a, setA] = useState('')
  const [b, setB] = useState('')
  // when props.x changed, only reset a, not b
  useComponentWillReceiveUpdate(() => {
    setA('')
  }, [props.x]);
}
```

If you're using useEffect like this:

```js
  const [state, setState] = useState(false)
  useEffect(() => setState(false), [props.someProp])
```

Don't do it. See [Adjusting some state when a prop changes](https://react.dev/learn/you-might-not-need-an-effect#adjusting-some-state-when-a-prop-changes) or [Storing information from previous renders](https://react.dev/reference/react/useState#storing-information-from-previous-renders)
It should be like this:
```js
  const [prev, setPrev] = useState(state)
  if (prev !== state) {
    setPrev(state)
    setState(false)
  }
```

This hook is a helper for the above pattern.

```js
useComponentWillReceiveUpdate(() => setState(false), [state])
```

This only applies to states of the current component.
Modifying states from other components causes React reporting errors.
You may also want to read [(Avoid) Notifying parent components about state changes](https://react.dev/learn/you-might-not-need-an-effect#notifying-parent-components-about-state-changes) and [(Avoid) Passing data to the parent](https://react.dev/learn/you-might-not-need-an-effect#passing-data-to-the-parent).
If you need to edit other components' states, write it like this:

```js
useComponentWillReceiveUpdate(() => {
  setLocalState(false)
  Promise.resolve().then(() => props.setParentState(false))
}, [state])
```
